<!DOCTYPE html>
<head>
    <title>3D Model</title>
    <style>
        body{
            background-color: #383838;
        }
        #canvas{
            position: fixed;
            transform: translate(-50%,-50%);
            left: 50vw;
            top: 50vh;
            border: red 1px solid;
        }
        #arrow_left{
            position: fixed;
            transform: translate(-50%,-50%);
            left: 10vw;
            top: 50vh;
            width: 10vw;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="500" height="500"></canvas>
    <img id="arrow_left" src="resource/arrow.png" onclick="">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.141.0/build/three.module.js",
                "GLTFLoader": "https://unpkg.com/three@0.141.0/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>
    <script type="module">
        import {GLTFLoader} from 'GLTFLoader';
        import * as THREE from 'three';

        let scene = new THREE.Scene();
        let renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#canvas'),
            antialias : true,
            alpha : true,
        });
        renderer.setClearColor( 0x000000, 0 );
        renderer.outputEncoding = THREE.sRGBEncoding;

        let camera = new THREE.OrthographicCamera(-5, 5, 5, -5, -0.5, 1000);
        camera.position.set(0,0,10);

        let loader = new GLTFLoader();
        let object;

        loader.load('resource/3dModel/001_icecream.gltf', function (gltf) {
            object = gltf.scene;
            scene.add(object);
            renderer.render(scene, camera);

            let isDragging = false;
            let previousMousePosition = {
                x: 0,
                y: 0
            };

            function handleMouseDown(event) {
                isDragging = true;
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }

            function handleMouseUp() {
                isDragging = false;
            }

            function handleMouseMove(event) {
                if (!isDragging) return;

                let deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };

                // 이전 마우스 위치와 현재 마우스 위치의 차이에 따라 오브젝트 회전
                object.rotation.y += deltaMove.x * 0.01;
                object.rotation.x += deltaMove.y * 0.01;

                renderer.render(scene, camera);

                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }

            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('mousemove', handleMouseMove);

            function animate(){
                requestAnimationFrame(animate)
                if (!isDragging) {
                    // 마우스 드래그 중이 아닐 때 회전
                    object.rotation.y -= 0.01;
                }
                renderer.render(scene, camera);
            }
            animate();
        });
    </script>
</body>
</html>
